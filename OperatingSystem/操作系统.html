<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <meta name="generator" content="VuePress 2.0.0-beta.35">
    <style>
      :root {
        --c-bg: #fff;
      }
      html.dark {
        --c-bg: #22272e;
      }
      html, body {
        background-color: var(--c-bg);
      }
    </style>
    <script>
      const userMode = localStorage.getItem('vuepress-color-scheme');
			const systemDarkMode = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches;
			if (userMode === 'dark' || (userMode !== 'light' && systemDarkMode)) {
				document.documentElement.classList.toggle('dark', true);
			}
    </script>
    <title>yjt</title><meta name="description" content="这是我的第一个 VuePress 站点">
    <link rel="modulepreload" href="/assets/app.7b29c1df.js"><link rel="modulepreload" href="/assets/操作系统.html.162392aa.js"><link rel="modulepreload" href="/assets/操作系统.html.46e5102e.js"><link rel="modulepreload" href="/assets/plugin-vue_export-helper.21dcd24c.js">
    <link rel="stylesheet" href="/assets/style.e8e8fc80.css">
  </head>
  <body>
    <div id="app"><!--[--><div class="theme-container"><!--[--><header ref_key="navbar" class="navbar"><div class="toggle-sidebar-button" title="toggle sidebar" aria-expanded="false" role="button" tabindex="0"><div class="icon" aria-hidden="true"><span></span><span></span><span></span></div></div><span><a href="/" class=""><img class="logo" src="https://vuejs.org/images/logo.png" alt="yjt"><span class="site-name can-hide">yjt</span></a></span><div class="navbar-items-wrapper" style=""><!--[--><!--]--><nav class="navbar-items can-hide"><!--[--><div class="navbar-item"><a href="/" class="" aria-label="Home"><!--[--><!--]--> Home <!--[--><!--]--></a></div><div class="navbar-item"><div class="navbar-dropdown-wrapper"><button class="navbar-dropdown-title" type="button" aria-label="STL"><span class="title">STL</span><span class="arrow down"></span></button><button class="navbar-dropdown-title-mobile" type="button" aria-label="STL"><span class="title">STL</span><span class="right arrow"></span></button><!--[--><ul style="display:none;" class="navbar-dropdown"><!--[--><li class="navbar-dropdown-item"><a href="/vector/vector.md" class="" aria-label="vector"><!--[--><!--]--> vector <!--[--><!--]--></a></li><!--]--></ul><!--]--></div></div><div class="navbar-item"><a class="external-link" href="https://github.com/yuanjiteng" rel="noopener noreferrer" target="_blank" aria-label="Github"><!--[--><!--]--> Github <span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span><!--[--><!--]--></a></div><!--]--></nav><!--[--><!--]--><button class="toggle-dark-button" title="toggle dark mode"><svg style="" class="icon" focusable="false" viewBox="0 0 32 32"><path d="M16 12.005a4 4 0 1 1-4 4a4.005 4.005 0 0 1 4-4m0-2a6 6 0 1 0 6 6a6 6 0 0 0-6-6z" fill="currentColor"></path><path d="M5.394 6.813l1.414-1.415l3.506 3.506L8.9 10.318z" fill="currentColor"></path><path d="M2 15.005h5v2H2z" fill="currentColor"></path><path d="M5.394 25.197L8.9 21.691l1.414 1.415l-3.506 3.505z" fill="currentColor"></path><path d="M15 25.005h2v5h-2z" fill="currentColor"></path><path d="M21.687 23.106l1.414-1.415l3.506 3.506l-1.414 1.414z" fill="currentColor"></path><path d="M25 15.005h5v2h-5z" fill="currentColor"></path><path d="M21.687 8.904l3.506-3.506l1.414 1.415l-3.506 3.505z" fill="currentColor"></path><path d="M15 2.005h2v5h-2z" fill="currentColor"></path></svg><svg style="display:none;" class="icon" focusable="false" viewBox="0 0 32 32"><path d="M13.502 5.414a15.075 15.075 0 0 0 11.594 18.194a11.113 11.113 0 0 1-7.975 3.39c-.138 0-.278.005-.418 0a11.094 11.094 0 0 1-3.2-21.584M14.98 3a1.002 1.002 0 0 0-.175.016a13.096 13.096 0 0 0 1.825 25.981c.164.006.328 0 .49 0a13.072 13.072 0 0 0 10.703-5.555a1.01 1.01 0 0 0-.783-1.565A13.08 13.08 0 0 1 15.89 4.38A1.015 1.015 0 0 0 14.98 3z" fill="currentColor"></path></svg></button><!----></div></header><!--]--><div class="sidebar-mask"></div><!--[--><aside class="sidebar"><nav class="navbar-items"><!--[--><div class="navbar-item"><a href="/" class="" aria-label="Home"><!--[--><!--]--> Home <!--[--><!--]--></a></div><div class="navbar-item"><div class="navbar-dropdown-wrapper"><button class="navbar-dropdown-title" type="button" aria-label="STL"><span class="title">STL</span><span class="arrow down"></span></button><button class="navbar-dropdown-title-mobile" type="button" aria-label="STL"><span class="title">STL</span><span class="right arrow"></span></button><!--[--><ul style="display:none;" class="navbar-dropdown"><!--[--><li class="navbar-dropdown-item"><a href="/vector/vector.md" class="" aria-label="vector"><!--[--><!--]--> vector <!--[--><!--]--></a></li><!--]--></ul><!--]--></div></div><div class="navbar-item"><a class="external-link" href="https://github.com/yuanjiteng" rel="noopener noreferrer" target="_blank" aria-label="Github"><!--[--><!--]--> Github <span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span><!--[--><!--]--></a></div><!--]--></nav><!--[--><!--]--><ul class="sidebar-items"><!--[--><li><p tabindex="0" class="sidebar-item sidebar-heading"> <!----></p><!--[--><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/OperatingSystem/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.html#操作系统知识点" class="router-link-active router-link-exact-active sidebar-item" aria-label="操作系统知识点"><!--[--><!--]--> 操作系统知识点 <!--[--><!--]--></a><!--[--><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/OperatingSystem/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.html#概述" class="router-link-active router-link-exact-active sidebar-item" aria-label="概述"><!--[--><!--]--> 概述 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/OperatingSystem/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.html#进程与线程" class="router-link-active router-link-exact-active sidebar-item" aria-label="进程与线程"><!--[--><!--]--> 进程与线程 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/OperatingSystem/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.html#内存管理" class="router-link-active router-link-exact-active sidebar-item" aria-label="内存管理"><!--[--><!--]--> 内存管理 <!--[--><!--]--></a><!----></li><!--]--></ul><!--]--></li><li><a aria-current="page" href="/OperatingSystem/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.html#面经以及回答" class="router-link-active router-link-exact-active sidebar-item" aria-label="面经以及回答："><!--[--><!--]--> 面经以及回答： <!--[--><!--]--></a><!----></li><!--]--></ul><!--]--></li><!--]--></ul><!--[--><!--]--></aside><!--]--><!--[--><main class="page"><!--[--><!--]--><div class="theme-default-content"><!--[--><p>参考：拓跋阿秀、帅地玩编程、小贺、星空之座 八股文 CSNote 《现代操作系统第四版》（陈向群译）</p><p>推荐视频教程 <a href="https://www.bilibili.com/video/BV1wq4y1M7qf?spm_id_from=333.337.search-card.all.click" target="_blank" rel="noopener noreferrer">爆肝上传！清华大佬终于把困扰我大学四年的【计算机操作系统】讲的如此通俗易懂_哔哩哔哩_bilibili<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></p><p>有时间建议一定花一两天阅读一遍 现代操作系统，比只看面经管用很多。</p><h2 id="操作系统知识点" tabindex="-1"><a class="header-anchor" href="#操作系统知识点" aria-hidden="true">#</a> 操作系统知识点</h2><h3 id="概述" tabindex="-1"><a class="header-anchor" href="#概述" aria-hidden="true">#</a> 概述</h3><h4 id="操作系统的定义" tabindex="-1"><a class="header-anchor" href="#操作系统的定义" aria-hidden="true">#</a> 操作系统的定义：</h4><p>资源管理观点和扩展的机器观点。在资源管理的观点中，操作系统的任务是有效管理系统的各个部分，在扩展的机器观点中，系统的任务是为用户提供比实际机器更加便于运用的抽象。包括进程，地址空间和文件等。</p><h4 id="计算机硬件基础" tabindex="-1"><a class="header-anchor" href="#计算机硬件基础" aria-hidden="true">#</a> 计算机硬件基础：</h4><p>一个简单个人计算机部件可以抽象为如下结构：</p><img src="/assets/pc.cb1cb06a.png"><p><strong>CPU</strong></p><p>每个CPU都有对应的专门<strong>指令集</strong>，因此x86处理器不能够处理ARM程序。由于直接访问内存得到指或者数据的时间比执行指令的时间还要长，因此CPU内部存在各种寄存器，比如程序计数器PC或者<strong>堆栈指针寄存器</strong>（用于保存相关输入参数 局部变量等）以及<strong>程序状态字寄存器（PSW)</strong>,控制各种CPU优先级，用户态/内核态切换 以及状态控制位。因此发生IO中断时候，操作系统应该将所有现场保留，处理中断程序，然后恢复寄存器恢复堆栈恢复执行之前的指令。为了改善性能，设计师设计了<strong>流水线机制</strong>，但是同样会增加操作系统设计的复杂度。现在更先进的做法是<strong>超标量CPU</strong>,即有多个CPU分别用于不同的运算，同时有多个不同的执行单元，执行单元在执行完当前指令之后之间向缓冲区读取待执行指令执行，现代分布式计算往往也存在这种<strong>缓冲申请设计</strong>。</p><p><strong>用户态和内核态</strong> PSW中存在一个控制位，当在内核态时候CPU可以执行<strong>指令集中的任意一条指令</strong>，并且使用硬件的每种功能，在台式机和服务器上，操作系统运行在内核态，嵌入式操作系统则部分在内核态部分在用户态，因此有内核编程这一说，参考学过的嵌入式中的kprintf。用户程序运行在用户态，仅能够执行指令集的一部分和硬件功能的一部分，有关的内存指令和IO读取是禁止的，因此可以推测出编程实现硬件操作：即用户系统调用（陷入内核）需要完成用户态到内核态的转换。</p><p><strong>存储器</strong></p><p>从快到慢：寄存器 高速缓存（L1 L2）主存 磁盘</p><p>最常用的高速缓存（硬件控制）放在CPU内部，比如某个程序需要读一个字时候，高速缓存硬件会检测需要的行是否在缓存中。如果是，则高速缓存命中，否则去主存中找，再其次去磁盘找。都是一个道理，即缓存机制用来提高执行效率，从而不用浪费时间在寻找内存位置上面。</p><p>现代CPU通常含有两级缓存，<strong>L1缓存</strong>用来将已经解码的指令调入CPU的执行引擎，L2缓存用来放置最近使用过的内存字，两个缓存的区别在于L2相比于L1缓存（不存在时延）存在一到两个时钟周期。</p><p>现代的内存条比如 DDR5 使用的是DDR SDRAM<strong>同步动态随机存储器</strong>，同步对象是系统时钟频率。</p><p>注意：<strong>ROM 和 RAM都是主存 也就是内存 只不过具有不同的性质</strong></p><p>而常说的外盘实际指的是硬盘（磁盘）、 EEPROM、固态硬盘（闪存）等。</p><p><strong>I/O设备</strong></p><p>实现输入输出的方式一般有三种：</p><p>一是忙等待，跳转直到IO设备空闲并且执行完IO处理再返回</p><p>二是中断， 根据设备状态判断是否执行中断，也存在中断优先级等</p><p>三是特殊的直接存储访问DMA，即将设备看做文件流处理，控制内存和某些控制器之间的位流,完成后再中断。</p><p><strong>总线</strong></p><p>PCIE总线采取串行总线方式 CPU通过DDR总线和内存对话，通过PCIE总线和图形设备对话，通过DMI总线和平台控制集成中心对话，然后可以通过各种PCIE插槽、SATA插槽、USB插槽连接外设。</p><p><strong>操作系统四个特征</strong>：并发（进程与线程）、共享（文件系统）、虚拟（内存管理）、异步（输入/出输出、系统调用）</p><p><strong>微内核概念 与之对应存在 单体系统、层次系统</strong></p><p>在分层方式（即分层设计操作系统，存在用户程序、输入输出、进程通信、存储管理等层次）中，需要界定内核-用户的边界，微内核的设计思想是为了实现高可靠性，将操作系统划分成各种小的模块，其中一个微内核执行在内核态，其余的作为普通用户进程。尽管这不安全，但是能够防止因为一点小错误造成整个系统死机，即现代设计中常见的容灾思想。例如再生服务器，当一个服务器出现错误时候立刻取代它，从而让系统具有自我修复能力。</p><h3 id="进程与线程" tabindex="-1"><a class="header-anchor" href="#进程与线程" aria-hidden="true">#</a> 进程与线程</h3><h4 id="进程线程管程概念区别" tabindex="-1"><a class="header-anchor" href="#进程线程管程概念区别" aria-hidden="true">#</a> <strong>进程线程管程概念区别</strong></h4><p>都是一种抽象的概念。</p><table><thead><tr><th style="text-align:left;"></th><th style="text-align:left;">进程</th><th style="text-align:left;">线程</th><th style="text-align:left;">管程</th></tr></thead><tbody><tr><td style="text-align:left;">定义</td><td style="text-align:left;">资源分配和拥有的基本单位</td><td style="text-align:left;">程序执行的基本单位</td><td style="text-align:left;">用户态的轻量级线程，线程内部调度的基本单位</td></tr><tr><td style="text-align:left;">切换情况</td><td style="text-align:left;">进程CPU环境(栈、寄存器、页表和文件句柄等)的保存以及新调度的进程CPU环境的设置</td><td style="text-align:left;">保存和设置程序计数器、少量寄存器和栈的内容</td><td style="text-align:left;">先将寄存器上下文和栈保存，等切换回来的时候再进行恢复</td></tr><tr><td style="text-align:left;">切换者</td><td style="text-align:left;">操作系统</td><td style="text-align:left;">操作系统</td><td style="text-align:left;">用户</td></tr><tr><td style="text-align:left;">切换过程</td><td style="text-align:left;">用户态-&gt;内核态-&gt;用户态</td><td style="text-align:left;">用户态-&gt;内核态-&gt;用户态</td><td style="text-align:left;">用户态(没有陷入内核)</td></tr><tr><td style="text-align:left;">调用栈</td><td style="text-align:left;">内核栈</td><td style="text-align:left;">内核栈</td><td style="text-align:left;">用户栈</td></tr><tr><td style="text-align:left;">拥有资源</td><td style="text-align:left;">CPU资源、内存资源、文件资源和句柄等</td><td style="text-align:left;">程序计数器、寄存器、栈和状态字</td><td style="text-align:left;">拥有自己的寄存器上下文和栈</td></tr><tr><td style="text-align:left;">并发性</td><td style="text-align:left;">不同进程之间切换实现并发，各自占有CPU实现并行</td><td style="text-align:left;">一个进程内部的多个线程并发执行</td><td style="text-align:left;">同一时间只能执行一个协程，而其他协程处于休眠状态，适合对任务进行分时处理</td></tr><tr><td style="text-align:left;">系统开销</td><td style="text-align:left;">切换虚拟地址空间，切换内核栈和硬件上下文，CPU高速缓存失效、页表切换，开销很大</td><td style="text-align:left;">切换时只需保存和设置少量寄存器内容，因此开销很小</td><td style="text-align:left;">直接操作栈则基本没有内核切换的开销，可以不加锁的访问全局变量，所以上下文的切换非常快</td></tr><tr><td style="text-align:left;">通信方面</td><td style="text-align:left;">进程间通信需要借助操作系统</td><td style="text-align:left;">线程间可以直接读写进程数据段(如全局变量)来进行通信</td><td style="text-align:left;">共享内存、消息队列</td></tr></tbody></table><h4 id="进程控制块pcb" tabindex="-1"><a class="header-anchor" href="#进程控制块pcb" aria-hidden="true">#</a> <strong>进程控制块PCB</strong></h4><p>进程控制块用于描述进程的状态和基本信息，进程的创建和和销毁都实际上改变这个控制块（表）的内容，其结构大致为：</p><img src="/assets/pcb.1523efcb.png" style="zoom:80%;"><h4 id="进程状态切换" tabindex="-1"><a class="header-anchor" href="#进程状态切换" aria-hidden="true">#</a> <strong>进程状态切换</strong></h4><p>当然还有挂起状态，写过多线程会比较清楚。</p><img src="/assets/process.561d74b1.png" style="zoom:80%;"><h4 id="进程调度" tabindex="-1"><a class="header-anchor" href="#进程调度" aria-hidden="true">#</a> <strong>进程调度</strong></h4><p>进程调度的算法同样适用与线程调度，调度的目的是为了实现在特定情况下的负载均衡。在操作系统中，CPU属于稀缺资源，因此需要设计调度算法提高CPU的利用率。</p><p>三种典型的进程调度环境</p><p>批处理环境：不会有用户在终端发出短请求 不需要有抢断行为</p><p><strong>先来先服务</strong> <strong>最短作业优先</strong> <strong>最短剩余时间优先</strong></p><p>交互式环境：为了避免占用和无限循环</p><p><strong>时间片轮转</strong> <strong>优先级队列</strong> <strong>多级反馈队列</strong> <strong>公平分享调度</strong></p><p>实时环境</p><p>软实时和硬实时系统，如果可以进行调度的实时要求可以进行上述调度算法选择</p><p><strong>进程同步</strong></p><p>临界区 信号量 互斥量 条件变量 管程</p><h4 id="进程通信方式和优缺点-需要通过操作系统" tabindex="-1"><a class="header-anchor" href="#进程通信方式和优缺点-需要通过操作系统" aria-hidden="true">#</a> <strong>进程通信方式和优缺点 需要通过操作系统</strong></h4><p>1 无名管道 linux管道命令符？</p><ul><li><p>相当于内核空间的一个特殊文件，无名管道的无名就是指这个虚幻的“文件”，没有名字</p></li><li><p>可以通过pipe函数来创建</p></li><li><p>pipe函数会在进程内核空间申请一块内存（比如一个内存页，一般是 4KB），然后把这块内存当成一个先进先出（FIFO）的循环队列来存取数据，这一切都由操作系统帮助我们实现了</p></li><li><p>无名管道只能进行半双工通信</p></li><li><p>如果想要实现全双工，可以再多开一个无名管道</p></li><li><p>本质上时内核缓冲区，当缓冲区满了或者空了，会控制相应的读写进程进入等待队列，等缓冲区满足条件后再唤醒对应的进程</p></li><li><p>由于无名管道没有名字，只是内核空间的一块内存，因此只适用于父子进程间的通信</p><ul><li>父进程通过pipe创建管道，获得读写文件描述符后，通过fork函数创建子进程</li><li>此时子进程拥有同样的文件描述符</li><li>由于无名管道半双工的特点，父子进程只能一个保留写一个保留读</li></ul></li></ul><p>2 有名管道</p><ul><li>有名管道使用一个实实在在的FIFO类型的文件，意味着即时没有亲缘关系的进程也可以相互通信了，只要不同的进程打开相同的FIFO文件即可</li><li>通过命令 mkfifo 创建FIFO类型文件</li><li>FIFO文件特点： <ul><li>文件属性前面标注的文件类型是 p，代表管道</li><li>文件大小是 0</li><li>fifo 文件需要有读写两端，否则在打开 fifo 文件时会阻塞</li><li>也会半双工</li></ul></li></ul><p>3 共享内存</p><ul><li><p>过程</p><ul><li>根据已知的key使用shmget函数获取或者创建内核对象，并且返回内核对象的id号 <ul><li>key一般是事先约定好的</li></ul></li><li>根据id号获取内存地址</li><li>向内存读写数据</li></ul></li><li><p>使得多个进程可以直接读写同一个内核中的内存空间</p></li><li><p>由于多个进程共享一段内存，因此需要依靠某种同步机制(如信号量)达到进程间的同步和互斥</p></li><li><p>速度相对来说是比较快的</p></li><li><p>因为两个进程的虚拟地址空间直接映射到同一个物理内存中</p></li><li><p>不用每次将数据从内核拷贝到用户空间再拷贝回去</p></li><li><p>基本上共享内存中的数据直到通信完成才会写回去文件中</p></li><li><p>因此一个共享内存只有两次复制，一次从文件到内存，一次从内存到文件</p></li><li><p>比较典型的linux内核支持方式就是mmap调用</p></li></ul><p>4 内核对象</p><ul><li><p>内核对象是位于内核空间的一个结构体</p></li><li><p>对于共享内存、消息队列和信号量，在内核空间中均有对应的结构体来描述</p></li><li><p>每个内核对象都有自己的id号，供用户空间使用</p></li><li><p>获取方法：</p><ul><li>shmget：共享内存</li><li>msgget：消息队列</li><li>semget：信号量</li></ul></li></ul><p>5 消息队列</p><ul><li><p>消息队列本质上是位于内核空间的链表，链表的每个节点都是一条消息。每一条消息都有自己的消息类型，消息类型用整数来表示，而且必须大于 0.</p></li><li><p>不同类型的消息被挂载到对应类型的链表上</p></li><li><p>消息类型为0的链表记录了所有消息加入队列的顺序</p></li><li><p>消息数据格式：</p><ul><li>需要保证首4字节是一个整数，代表消息类型，大于0</li><li>消息正文可以依照需求设计</li></ul></li><li><p>好处</p><ul><li>克服了消息传递信息小，管道只能承载无格式字节流以及缓冲区大小受限的不足</li><li>它独立于发送和接收进程存在，避免有名管道的同步和阻塞问题</li></ul></li><li><p>核心函数：</p><ul><li>msgsnd</li><li>msgrcv</li><li>msgget</li></ul></li></ul><p>信号量</p><ul><li>信号量是一个计数器，一般用于进程同步以及多进程对共享资源的访问</li><li>等待(P(sv))就是将其值减一或者挂起进程，发送(V(sv))就是将其值加一或者将进程恢复运行</li></ul><p>7 信号 例如 kill命令</p><ul><li><p>信号产生条件</p><ul><li>按键</li><li>硬件异常</li><li>进程调用kill函数将信号发送给另外一个进程</li></ul></li><li><p>信号传递的消息较少，一般用于通知进程某个事件的发生</p><ul><li>通过注册信号处理函数来对接收到的信号进行处理</li></ul></li><li><p><strong>kill -pid</strong></p><ul><li>标准的kill命令通常都能达到目的。终止有问题的进程，并把进程的资源释放给系统。然而，如果进程启动了子进程，只杀死父进程，子进程仍在运行，因此仍消耗资源。为了防止这些所谓的“僵尸进程”，应确保在杀死父进程之前，先杀死其所有的子进程。</li><li>ps -ef | grep httpd 找到要杀死的父进程和子进程</li></ul></li><li><p><strong>kill -l PID</strong></p><ul><li>-l选项告诉kill命令用好像启动进程的用户已注销的方式结束进程。当使用该选项时，kill命令也试图杀死所留下的子进程。但这个命令也不是总能成功--或许仍然需要先手工杀死子进程，然后再杀死父进程</li></ul></li><li><p><strong>kill -TERM PPID</strong></p><ul><li>给父进程发送一个TERM信号，试图杀死它和它的子进程。</li></ul></li><li><p><strong>kill -HUP PID</strong></p><ul><li>该命令让Linux和缓的执行进程关闭，然后立即重启。在配置应用程序的时候，这个命令很方便，在对配置文件修改后需要重启进程时就可以执行此命令。</li></ul></li><li><p>绝杀 <strong>kill -9 PID</strong></p><ul><li>kill -s SIGKILL</li><li>这个强大和危险的命令迫使进程在运行时突然终止，进程在结束后不能自我清理。危害是导致系统资源无法正常释放，一般不推荐使用，除非其他办法都无效。</li></ul></li></ul><p>8 套接字 sockets</p><ul><li>用于更为一般的进程间通信</li><li>可以用于不同机器间的进程通信</li></ul><h4 id="不同通信方式的优缺点" tabindex="-1"><a class="header-anchor" href="#不同通信方式的优缺点" aria-hidden="true">#</a> <strong>不同通信方式的优缺点？</strong></h4><ul><li>管道：速度慢，容量有限；</li><li>Socket：任何进程间都能通讯，但速度慢；</li><li>消息队列：容量受到系统限制，且要注意第一次读的时候，要考虑上一次没有读完数据的问题；</li><li>信号量：不能传递复杂消息，只能用来同步；</li><li>共享内存区：能够很容易控制容量，速度快，但要保持同步，比如一个进程在写的时候，另一个进程要注意读写的问题，相当于线程中的线程安全，当然，共享内存区同样可以用作线程间通讯，不过没这个必要，线程间本来就已经共享了同一进程内的一块内存。</li></ul><h4 id="进程出现的原因-线程出现的原因-管程出现的原因" tabindex="-1"><a class="header-anchor" href="#进程出现的原因-线程出现的原因-管程出现的原因" aria-hidden="true">#</a> 进程出现的原因？线程出现的原因？管程出现的原因？</h4><p>进程的出现是为了让计算机能够同时执行多个程序，尽管这个计算机只有一个cpu核，实现方式就是进程调度。</p><p>多线程出现原因：可以真正实现并行能力，上下文切换更快，并行实体拥有共享一个地址空间和所有可用数据的能力；由于线程比进行更加轻量，创建和撤销都更加简单；对于大量的IO处理，多个线程会加快应用程序执行的速度</p><p>管程出现原因：使用信号量之类的同步算法需要非常小心，因此提出一种高级原语管程，使用语言概念。类似于对于信号量的包装，但是实际使用的是条件变量，想要使用需要编程语言和编译器支持。</p><h4 id="用户级线程和内核线程" tabindex="-1"><a class="header-anchor" href="#用户级线程和内核线程" aria-hidden="true">#</a> 用户级线程和内核线程</h4><p>用户级多线程和内核级多线程的优缺点（只是不同的原理方式，实际上运行的是什么不一定）</p><p>用户级线程：内核并不知道存在多线程，执行的实际上是单线程进程（直接原理上同步？），也就是线程表位于用户空间，优点是不用陷入内核，不用上下文切换，只需要根据线程表去改变堆栈指针和程序计数器。缺点是 如何实现阻塞系统调用，例如想要使用一个线程读取键盘数据，如果要实现就需要线程表中所有其他的线程阻塞 比较相近的有缺页中断问题，比如又一个线程执行时发生了缺页中断，这样整个进程都会阻塞，直到IO读取完成，尽管这个进程中其他的线程能够执行。</p><p>内核级多线程：在内核中存在线程表，开销比较大，因此存在回收机制。此外需要进行阻塞系统调用，如果某个进程中的线程存在缺页中断，由于内核知道线程表，因此可以实现调度运行其他能够执行的线程，不会阻塞。</p><p>通常内核级多线程优点大但是时间慢，因此存在调度程序激活机制用于用户级线程，也就是加了阻塞判断之类，出现上行调用，也就是内核调用应用程序，违反层次架构的概念。</p><p>弹出式线程：分布式中使用，一个消息的到达导致创建一个处理这个消息的线程，可以使得消息到达和开始处理时间非常短 但是也有缺点。</p><h3 id="内存管理" tabindex="-1"><a class="header-anchor" href="#内存管理" aria-hidden="true">#</a> 内存管理</h3><p>虚拟内存机制（虚拟机制）</p><h4 id="死锁" tabindex="-1"><a class="header-anchor" href="#死锁" aria-hidden="true">#</a> 死锁</h4><p>死锁的必要条件：互斥 占有和等待 不可抢占 环路等待</p><p>死锁的处理方法：</p><p>鸵鸟策略</p><p>死锁检测和死锁恢复：破坏互斥条件 破坏占有和等待条件 破坏不可抢占条件 破坏环路等待</p><p>死锁避免：安全状态 银行家算法</p><h4 id="内存管理-1" tabindex="-1"><a class="header-anchor" href="#内存管理-1" aria-hidden="true">#</a> 内存管理</h4><p>虚拟内存</p><p>分页系统地址映射</p><p>页面置换算法：最佳 最近最久未使用 最近未使用 先进先出 第二次机会 clock时钟算法</p><p>分段技术 分页和分段的比较</p><h4 id="磁盘管理" tabindex="-1"><a class="header-anchor" href="#磁盘管理" aria-hidden="true">#</a> 磁盘管理</h4><p>磁盘调度算法：先来先服务 最短寻道时间 电梯算法</p><h2 id="面经以及回答" tabindex="-1"><a class="header-anchor" href="#面经以及回答" aria-hidden="true">#</a> 面经以及回答：</h2><p>拓跋阿秀面经问题：</p><p>1、进程、线程和协程(管程) 的区别</p><p>定义 切换情况 切换者切换过程 调用栈 拥有资源 并发性 系统开销 通信方面</p><p>2、一个进程可以创建多少个线程</p><p>3、外中断和异常的区别</p><p>4、 原子操作</p><p>5、进程调度算法</p><p>6、linux下进程通信</p><p>7、linux下同步机制</p><p>8、系统中存在块表之后，地址的转换过程变成什么样了？</p><p>9、动态分区分配算法有哪几种？详细说说？</p><p>首次适应算法 最佳适应算法 最坏适应算法 临近时应算法</p><p>10 虚拟技术 （时分复用和空分复用技术）</p><p>13 进程状态以及切换（七种和五种）</p><p>14 程序从开始到运行结束的完整过程？</p><p>预编译 编译 汇编 链接(动态 静态)</p><p>15、通过例子讲解逻辑地址转换为物理地址的基本过程。</p><p>16、进程同步的四种方法？</p><p>17、操作系统在对内存进行管理的时候需要做些什么？</p><p>18、进程通信方法？线程通信方式？</p><p>19、虚拟内存的目的是什么？</p><p>20、什么是内存、作用？</p><p>24、介绍一下几种典型的锁？</p><p>读写锁、互斥量、条件变量、自旋锁？</p><p>25、怎么回收线程？有几种方法？</p><p>26、内存的覆盖是什么？有什么特点？(页面交换)</p><p>27、内存交换技术和使用时间？</p><p>28、如何让进程后台运行？（</p><p>比较常见的是</p><p>① nobup 命令 +&amp;</p><p>② ctrl+z 直接挂起进程</p><p>③ 将命令+&amp;放在（）里面</p><p>④使用screen命令</p><p>29、什么是块表？有什么用？</p><p>30、守护进程、僵尸进程、孤儿进程、</p><p>31、如何避免僵尸进程？</p><p>32、子进程 父进程 作业和会话？</p><p>33、进程终止的几种方式？ 五种</p><p>34、中断和异常的区别？</p><p>中断：硬件 异常：cpu</p><p>35、一般情况下linux和windows平台下栈空间的大小？</p><p>36、程序从堆中动态分配内存时候，虚拟内存上怎么操作的？</p><p>37、抖动是什么?</p><p>38、内存交换中，被换出的进程保存在哪里?</p><p>39、内存置换算法？</p><p>40、为什么分段式存储管理系统有外部碎片而无内部碎片？</p><p>41、如何消除碎片文件？</p><p>「herongwei」面试题目总结 与上面相同的不记录：</p><p>42、递归锁？</p><p>43、函数调用和系统调用？</p><p>44、常⻅的IO模型，五种？异步IO应⽤场景？有什么缺点？</p><p>45、IO复用的原理？零拷贝？(网络编程)</p><p>操作系统的面经到此结束，具体进程线程代码在unix 网络编程中学</p><!--]--></div><footer class="page-meta"><!----><div class="meta-item last-updated"><span class="meta-item-label">Last Updated: </span><!----></div><div class="meta-item contributors"><span class="meta-item-label">Contributors: </span><span class="meta-item-info"><!--[--><!--[--><span class="contributor" title="email: yuanjiteng@whu.edu.cn">yuanjiteng</span><!--[-->, <!--]--><!--]--><!--[--><span class="contributor" title="email: 49592982+yuanjiteng@users.noreply.github.com">Jiteng Yuan</span><!----><!--]--><!--]--></span></div></footer><!----><!--[--><!--]--></main><!--]--></div><!----><!--]--></div>
    <script type="module" src="/assets/app.7b29c1df.js" defer></script>
  </body>
</html>
